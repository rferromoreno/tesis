% Chapter 2

\chapter{Sistema de Tipos} % Main chapter title

\label{Chapter2} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------

JavaScript es un lenguaje de "`scripting"', con tipado dinámico y un sistema de tipos débil. Generalmente, en este tipo de lenguajes interpretados no es necesario definir el tipo de una variable al momento de declararla, por lo que es lógico preguntarse ?`Es JavaScript un lenguaje seguro?. En este capítulo se abordará las cuestiones de JS relativas a su sistema de tipos.

%----------------------------------------------------------------------------------------

\section{Tipos primitivos}

Tal como se mencionó en el Capítulo \ref{Chapter1}, existen solamente 7 tipos primitivos del lenguaje. Una variable está asociada a un valor, y dicho valor puede ser de alguno de los siguientes tipos:

\begin{itemize}
\item \code{undefined}
\item \code{null}
\item \code{number}
\item \code{string}
\item \code{boolean}
\item \code{symbol}
\item \code{object}
\end{itemize}

Algunos autores consideran que \code{Object} no es un tipo primitivo, sino que es un tipo que hereda de \code{Null}. Por otro lado, hay que mencionar que las funciones en JavaScript son consideradas objetos, por lo que \code{Function} es un subtipo de \code{Object}.

Para el análisis del tipo de un valor (o del valor de una variable) en ejecución, se puede hacer uso del operador \code{typeof}. Dicho operador retorna un String con el nombre del tipo del valor evaluado.

\begin{lstlisting}[title={Analizando los tipos con \code{typeof}}]
typeof undefined		// retorna "undefined"
typeof 123					// retorna "number"
typeof true					// retorna "boolean"
typeof {}						// retorna "object"
typeof "Hola Mundo" // retorna "string"
typeof Symbol()			// retorna "symbol"
\end{lstlisting}

Una de las primeras flaquezas presentadas por el lenguaje es la del \code{typeof null}. 

\begin{lstlisting}[title={Analizando \code{typeof null}}]
typeof null					// retorna "object"
\end{lstlisting}

Uno tiende a esperar que \code{typeof null} retorne "\code{null}", sin embargo, retorna "\code{object}". Este es un \textit{bug} conocido y difícilmente sea corregido, ya que se estima que hay muchas aplicaciones y sistemas en la web que se basan en este comportamiento. Se cree que corregir esto crearía más problemas que soluciones.

Esto no solo pasa con el literal \code{null} sino que además sucederá con cualquier variable ligada a un tipo nulo.

\begin{lstlisting}[title={Analizando \code{typeof null} (cont.)}]
var a = null;
typeof a					// retorna "object"
\end{lstlisting}

\subsection{Casos especiales del \code{typeof}}

Existen algunos casos especiales para el operador \code{typeof}. ?`Qué pasa con las funciones?. ?`Y con los arreglos?. ?`Y con los tipos built-in pero que no son primitivos (también conocido como "`nativos"')?. Vamos por partes.

El primero de los casos es el de las \textbf{funciones}. Como se mencionó anteriormente, en la especificación, una función es considerada un subtipo de \code{object}, a diferencia de que tiene una propiedad interna \code{[[Call]]}. Sin ir más lejos, ?`qué se espera que retorne \code{typeof} para el caso de una función?

\begin{lstlisting}[title={Analizando \code{typeof} de una función}]
typeof function a(){}					// retorna "function"
\end{lstlisting}

Si bien quizás resulte más intuitivo esperar que retorne "\code{object}", el hecho de que haya retornado "\code{function}" puede resultar útil a la hora de distinguir entre objetos y funciones, y así identificar cuales son los que se pueden invocar (también conocidos como "`callable objects"'). Sin embargo, este hecho es algo contradictorio ya que "\code{function}" no está distinguido entre los tipos primitivos.

El otro caso especial es el de los \textbf{arreglos}. En JavaScript, un arreglo no es más que un objeto con una propiedad interna \code{length}, donde cada propiedad de la instancia del objeto es el índice del arreglo.

\begin{lstlisting}[title={Analizando \code{typeof} de arreglos}]
typeof []									// retorna "object"
typeof [1, 2, 3]					// retorna "object"
typeof ["hola", "mundo"]	// retorna "object"
\end{lstlisting}

?`Por qué para las funciones el operador \code{typeof} devuelve \code{function} mientras que para los arreglos sigue devolviendo \code{object}? 

Al parecer, la distinción de los "`callable objects"' es importante para el lenguaje, pero para el caso de arreglos es irrelevante saber si un arreglo es efectivamente un arreglo o simplemente un objeto, dado que tienen las mismas propiedades y se lo puede tratar de la misma manera. ?`Cómo saber entonces cuando -por ejemplo- una variable es un objeto o un arreglo? La respuesta es mediante el operador \code{instanceof}. La distinción se hace mediante el análisis de la clase asociada, y no del tipo.


%----------------------------------------------------------------------------------------

\section{Lo bueno, lo malo, lo feo...}
