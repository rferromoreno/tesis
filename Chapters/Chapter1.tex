% Chapter 1

\chapter{Introducción a JavaScript} % Main chapter title

\label{Chapter1} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\tabhead}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{\bfseries#1}}
\newcommand{\option}[1]{\texttt{\itshape#1}}
\newcommand{\nuevo}[1]{\fcolorbox{red}{white}{%
    \minipage[t]{\linewidth\fboxsep\fboxrule\relax}
        #1
    \endminipage}}

%----------------------------------------------------------------------------------------

\section{Historia de JavaScript}

JavaScript, comunmente abreviado como \textsc{JS}, es un lenguaje de programación interpretado. En los comienzos, el lenguaje se utilizaba para agregar dinamismo del lado del cliente a las páginas web. Sin embargo, hoy en día se pueden crear aplicaciones de escritorio o del lado del servidor.

El lenguaje fue creado por \textbf{Brendan Eich} en 1995, quien en ese entonces trabajaba para Netscape. Eich denominó a su lenguaje \texttt{LiveScript}, y el objetivo inicial del lenguaje era solucionar problemas de validación de formularios complejos en el lado del cliente para el navegador Netscape Navigator, tratando de adaptarlo a tecnologías ya existentes. 

La empresa Netscape junto con Sun Microsystems desarrollaron en conjunto este lenguaje de programación. Pero por cuestiones de mercado antes del lanzamiento, Netscape decidió cambiar el nombre del lenguaje a JavaScript (ya que en ese entonces Java estaba de moda en el mundo informático).

Al poco tiempo, la empresa Microsoft lanzó \texttt{JScript} para Internet Explorer. Para no entrar en una guerra informática, Netscape decidió que lo mejor sería estandarizar el lenguaje. Para ello, enviaron la especificación de JavaScript 1.1 al organismo ECMA (European Computer Manufacturers Association).

ECMA creó el comité TC39 con el objetivo de "\emph{estandarizar de un lenguaje de script multiplataforma e independiente de cualquier empresa}". El primer estándar que creó el comité TC39 se denominó ECMA-262, en el que se definió por primera vez el lenguaje ECMAScript (abreviado comunmente como \texttt{ES}).

Es así entonces, que cuando hablamos de JavaScript, estamos haciendo referencia a una implementación de lo que se conoce como \texttt{ECMAScript}. El estándar ha ido evolucionando con el paso del tiempo. En la actualidad, la mayoría de los navegadores corren algún intérprete que soporta la mayoría de las características de las versiones 5.1 y 6. 

Aunque la última versión sea la de ECMAScript 8 (lanzada en Junio de 2017), la versión 6 es más popular, ya que en ésta se han agregado muchos cambios significativos para el lenguaje. En este documento se hará énfasis en las versiones 5.1 y 6.

%----------------------------------------------------------------------------------------

\section{JavaScript en la actualidad}

Después de más de 20 años de existencia, los usos del lenguaje han cambiado. JavaScript ya no es más un lenguaje para hacer validaciones de formularios complejos en páginas de Internet, ni tampoco para agregar dinamismo o animaciones a las páginas.

En la actualidad, se puede afirmar que JavaScript está en "`la cresta de la ola"'. ?`Qué se puede hacer hoy en día con JavaScript?

\begin{itemize}
	\item Páginas Web -- Pareciera la respuesta obvia, sin embargo la forma de crear sitios web ha cambiado con el paso del tiempo. Hoy en día existe una gran cantidad de librerías y frameworks basados en JavaScript, tales como \keyword{React}, \keyword{AngularJS} o \keyword{Vue.JS}, entre otros.
	\item Aplicaciones móviles -- Se pueden crear aplicaciones para celulares o dispositivos móviles programando en JavaScript, usando \keyword{Apache Cordova}, \keyword{Sencha}, \keyword{Ionic}, \keyword{NativeScript} o \keyword{Tabris.JS}.
	\item Aplicaciones de escritorio -- Así como recién se hizo mención de las aplicaciones móviles, las de escritorio no se quedan atrás. Algunos frameworks como \keyword{Electron} ó \keyword{NW.JS} permiten crear aplicaciones multiplataforma.
	\item Robots -- Mediante frameworks como \keyword{Cylon.JS} se pueden manejar dispositivos de hardware o robots. También existen kits basados en Arduino para programar en JS, tales como \keyword{Johnny-Five} o \keyword{Nodebots}.
	\item Aplicaciones de consola -- Existen librerias que facilitan el uso de la creación de aplicaciones de linea de comandos (CLI).
	\item Machine Learning -- Así como Python tiene una gran base de librerías para prototipar sistemas que apliquen Machine Learning, en este último tiempo la comunidad de JavaScript ha seguido los mismos pasos.
\end{itemize}

%----------------------------------------------------------------------------------------


\section{Características del lenguaje}

JavaScript es un lenguaje de alto nivel, interpretado y multiparadigma. Es dinámica y débilmente tipado. 

Posee herencia basada en prototipos. Este tipo de herencia es muy particular, y muy pocos lenguajes lo tienen. 

Se dice que es multiparadigma porque soporta los paradigmas imperativo, funcional, orientado a objetos (prototipado) y dirigido por eventos.

En el ecosistema de la Web, JavaScript es uno de los lenguajes más populares. Todos los navegadores en la actualidad tienen un intérprete del lenguaje.

Si bien tiene bastantes partes criticables, JavaScript tiene la fama de ser un lenguaje "`\textit{liviano}"' y "`\textit{expresivo}"'.

\subsection{Influencias}

JavaScript tiene fuertes influencias de varios lenguajes. Sus características más sobresalientes surgen de los siguientes lenguajes: 

\keyword{Java y C} -- No solo tiene la influencia sobre el nombre, sino que además tiene influencia sobre la sintaxis del lenguaje. Tanto Java como JavaScript sintácticamente emergen del lenguaje C. Sin embargo, Java y JavaScript tienen semánticas y propósitos diferentes.

\keyword{Perl y Python} -- Tanto Perl como Python han influido en el manejo de strings, arreglos y expresiones regulares en JavaScript.

\keyword{Scheme} -- De la familia del paradigma funcional. Adopta las funciones de primera clase y \textit{closures}, los cuales se tratarán más adelante.

\keyword{Self} -- Un lenguaje desarrollado por Sun Microsystems. Es de los pocos lenguajes que tienen herencia prototipada. Además de ésta característica, también se adopta la inusual notación de objetos.

\subsection{Intérpretes}

Ya se ha mencionado que JavaScript es un lenguaje interpretado. Sin embargo es necesario mencionar algunos "`motores"' que se encargan de interpretar el código en JavaScript.

Actualmente la gran mayoría de los navegadores (web browsers) viene con un intérprete de JS incorporado. A continuación se mencionan algunos de los más populares:

\begin{itemize}
\item \keyword{Rhino} -- Gestionado por la fundación Mozilla, es de código abierto y está desarrollado completamente en Java.
\item \keyword{SpiderMonkey} -- También desarrollado por Mozilla para el navegador Firefox. Escrito en C++. Es utilizado en proyectos como MongoDB y GNOME.
\item \keyword{Chakra} -- Desarrollado por Microsoft, primero para Internet Explorer, y luego para Microsoft Edge.
\item \keyword{V8} -- El motor por defecto para Google Chrome, y también utilizado Node.JS, Opera y otros proyectos populares. Escrito en C++, maneja alocación en memoria y posee garbage collector.
\item \keyword{JavaScriptCore} -- Es utilizado por navegadores como Safari o PhantomJS. También es conocido como SquirrelFish o Nitro, bajo proyectos similares con otro nombre por cuestiones de mercado.
\end{itemize}

El objetivo de esta sección no es entrar en detalle ni hacer un análisis comparativo de los intérpretes. Basta con hacer una pequeña búsqueda para notar que varios de éstos intérpretes poseen garbage collection, compilación JIT (just in time), y estrategias para la optimización del código.

A lo largo de este documento se mostrarán ejemplos de código, cuya interpretación se realizará utilizando Node.JS (V8), y la consola de los navegadores Google Chrome (V8) y Mozilla Firefox (SpiderMonkey).

En caso de que el lector quiera ejecutar el código JavaScript, se deja a disposición los enlaces de descarga de las herramientas mencionadas:

\begin{itemize}
\item Node.JS -- \href{https://nodejs.org/es/}{nodejs.org}
\item Google Chrome -- \href{https://google.com/chrome}{google.com/chrome}
\item Mozilla Firefox -- \href{https://www.mozilla.org/firefox}{mozilla.org/firefox}
\end{itemize}

Para abrir el intérprete desde Node.JS, basta con escribir \code{node} en la línea de comandos. Mientras que para el caso de los navegadores, hace falta apretar la tecla F12 para abrir la consola.

%---------------------------------------------------------------------------------------

\section{Nociones básicas}

\subsection{Tipos primitivos}

\subsubsection{Undefined} 
El tipo indefinido tiene un único valor, \code{undefined}. A toda variable que aún no se le haya asignado valor, tendrá el valor \code{undefined}.

\subsubsection{Null} 
El tipo nulo tiene un único valor, \code{null}, que representa al valor nulo o "`vacío"'.

\subsubsection{Boolean} 
El tipo booleano representa una entidad lógica con dos posibles valores, \code{true} ó \code{false}.

\subsubsection{String} 
Utilizado para representar datos de texto, el tipo String está definido como cero o más elementos, donde cada elemento es un entero no signado de 16 bits, de una longitud máxima de $2^{52}-1$ elementos.

\subsubsection{Number} 
Representa al conjunto de datos numérico. Se basa en la norma IEEE 754-2008, formato doble precisión de 64 bits en la aritmética de punto flotante. Toma algunos valores especiales de este conjunto para representar datos como NaN (Not a Number) y también +Infinity y -Infinity. La cantidad de valores reservados para NaN es dependiente de la implementación.

\subsubsection{Symbol} 
Fue agregado en la versión de ES6. Abarca el conjunto de todos los valores no String que pueden ser usados como clave en la propiedad de un Object. Cada valor posible de Symbol es único e inmutable. Se los puede pensar como tokens que sirven como identificadores únicos. 

\subsubsection{Object} 
Es la forma básica de representar un objeto en JavaScript. Está compuesto por una colección de propiedades.

Las propiedades se identifican usando claves. El valor de una clave puede ser o bien un String, o bien un Symbol. Todos los valores String y Symbol son válidos como nombre clave para una propiedad, inclusive la cadena vacía. 

\subsection{Palabras reservadas}

Las palabras reservadas del lenguaje se dividen en cuatro conjuntos:

\begin{itemize}
\item Palabras claves (\textit{keywords})
\item Palabras reservadas a futuro
\item Literal nulo (\code{null})
\item Literales booleanos (\code{true} y \code{false})
\end{itemize}

Las siguientes son palabras claves, a excepción de \code{null}, \code{true} y \code{false}, que son literales.

\begin{table}[!h]
\caption{Lista de palabras claves del lenguaje.}
\label{tab:reservedkeywords}
\centering
\begin{tabular}{l l l l}
\toprule
break & do & import & throw\\
case & else & in & true\\
catch & export & instanceof & try\\
class & extends & new & typeof\\
const & false & null & var\\
continue & finally & return & void\\
debugger & for & super & while\\
default & function & switch & with\\
delete & if & this & yield\\
\bottomrule\\
\end{tabular}
\end{table}

Por otro lado, existe un conjunto de palabras reservadas a futuro. En un principio son solamente dos: \code{await} y \code{enum}. Pero si se especifica la directiva de \textit{strict mode}, aparecen otras más: \code{implements}, \code{interface}, \code{package}, \code{private}, \code{protected} y \code{public}.

En resumen, las palabras reservadas a futuro (en modo estricto) son:

\begin{table}[!h]
\caption{Lista de palabras reservadas a futuro.}
\label{tab:futurereservedkeywords}
\centering
\begin{tabular}{l l l l}
\toprule
await & implements & package & protected\\
enum & interface & private & public\\
\bottomrule\\
\end{tabular}
\end{table}

\subsection{Otras cuestiones a tener en cuenta}

\subsubsection{Identificadores}

\begin{itemize}
\item Un identificador debe comenzar con una letra, signo pesos (\$), ó guión bajo (\textunderscore).
\item Un identificador consiste en letras, números, signo pesos (\$), ó guión bajo (\textunderscore).
\item Se permiten caracteres Unicode.
\item No se permite el uso de palabras reservadas como identificadores.
\end{itemize}

\subsubsection{Sensible a las mayúsculas}

JavaScript es un lenguaje sensible a las mayúsculas, lo que significa que se entiende a \code{miVariable} y a \code{MIVARIABLE} como dos identificadores totalmente diferentes.

\subsubsection{Sin tipado estático}

El lenguaje no posee tipado estático. Sin embargo con \textbf{Microsoft TypeScript} o \textbf{Facebook Flow} se puede alcanzar esto mediante el uso de \textit{type annotations}. Consiste en utilizar el lenguaje haciendo anotaciones de los tipos, para luego hacer un chequeo de tipos estáticos mediante un preprocesado del código. Tanto TypeScript como Flow son extensiones de JavaScript. 

\section{Sintaxis}

A continuación se hará una introducción sintáctica al lenguaje de forma breve y mediante ejemplos. El objetivo de esta sección no es detallar la especificación del lenguaje, sino dar un repaso general por los elementos básicos, las estructuras de control y de repetición. Para mayor detalle sobre la sintaxis, se recomienda leer el "`Standard ECMA-262 (Language Specification)"'.

\subsection{Comentarios}

Los comentarios en JavaScript se realizan de forma similar a los lenguajes influenciados por C (como por ejemplo JavaScript o C++). Es posible hacer comentarios inline, asi como también multilínea.

\begin{lstlisting}[title={Comentario inline}]
// Esto es un comentario en una sola linea
\end{lstlisting}

\begin{lstlisting}[title={Comentario multilinea}]
/* 
Esto es un comentario
escrito en varias lineas
*/
\end{lstlisting}

\subsection{Variables}

Para la declaración de variables, el lenguaje posee la palabra reservada \code{var}. Una variable tendrá el valor inicial \code{undefined} a menos que se la inicialice en su declaración.

También se pueden hacer múltiples declaraciones en la misma línea, incluso con la asignación de un valor inicial.

\begin{lstlisting}[title={Declarando variables}]
var a;									// Definiendo una variable con nombre a
var b = 1; 	 						// Definiendo una variable con nombre b
var c, d, e;	 					// Definiendo varias variables
var f, g = true, h;			// Esto tambien es valido
var i = "Hola", j = 2;	// Definiendo y asignando multiples variables
\end{lstlisting}

Vale la pena hacer mención también a dos nuevas formas de definir variables a partir de ES6. Se trata de \code{let} y \code{const}.

Sobre \code{let}, es una forma de declarar variables de alcance local. Se hará énfasis en este punto en futuros capítulos cuando se muestren los problemas de alcance que posee el lenguaje.

Por el lado de \code{const}, se tratan de variables de valor constante, cuyo valor no se puede cambiar y tampoco pueden ser redeclaradas.

\subsection{Estructuras condicionales}

El lenguaje posee las estructuras condicionales ya conocidas en lenguajes como C++ o Java. A continuación se muestran algunos ejemplos de algunas, que servirán para mejor entendimiento del código de ejemplo dado en los otros capítulos.

\subsubsection{Condicionales \code{if} e \code{if-else}}

\begin{lstlisting}[title={Ejemplos de \code{if} e \code{if-else}}]
if (a > 0) {
	// bloque si la condicion es verdadera 
}

if (a > 0) {
	// bloque si la condición es verdadera
} else {
	// bloque si la condición es falsa
}
\end{lstlisting}

\subsubsection{Operador ternario \code{?:}}

\begin{lstlisting}[title={Operador ternario \code{?:}}]
var mayor = a > b ? a : b
\end{lstlisting}

\subsection{Funciones}

Las funciones en JavaScript son objetos, instancia de \code{Function}. Al ser objetos, las mismas pueden ser guardadas como valores dentro de variables. Existen diferentes maneras de declarar una función. A continuación se enumeran 

\subsubsection{Funciones como expresión}

Una función como expresión (o función expresión) es una expresión que produce un valor, en este caso un objeto función, y luego es asignado a una variable.

\begin{lstlisting}[title={Función expresión}]
var suma = function (x, y) { return x + y };

suma(2,3); // devuelve 5
\end{lstlisting}

\subsubsection{Funciones como declaración}

Una función como declaración (o función declaración) funciona de la misma forma que la función expresión, a diferencia de que no es necesario recurrir a la asignación sino que ésta se hace automáticamente.

\begin{lstlisting}[title={Función declaración}]
function suma(x, y) { return x + y };

suma(2,3); // devuelve 5
\end{lstlisting}

\subsubsection{Funciones anónimas y arrow functions}

Se les llama funciones anónimas simplemente a aquellas funciones que no tienen nombre. Notar el detalle que cuando se habló de función como expresión, el lado derecho de la asignación era una función anónima.

Por otro lado, a partir de ES6 se introdujo el concepto de \code{arrow function} (o \code{fat arrow}, el cual está actualmente en varios lenguajes. Para el caso de JS, establece una forma más simple y concisa para escribir funciones anónimas, bajo el detalle de que además la palabra \code{this} dentro de la función no cambia ni está ligada a un nuevo contexto, sino que sigue está ligada léxicamente al contexto donde fue invocada. Esto último no sucede con las funciones como expresión comunes, ya que en éstas se crea un scope nuevo.

\begin{lstlisting}[title={\code{Arrow function}}]
var mostrar = (texto) => console.log(texto);

mostrar('hola!'); // hola!
\end{lstlisting}

\section{Otros conceptos}

Para entendimiento del lector, se presentan algunos conceptos que se mencionarán en algunos capítulos. Algunos no son exclusivos del lenguaje, pero comprender y saber que el lenguaje dispone de éstas cualidades, ayudará a explicar cómo funcionan otras características que se presentarán más adelante.

\subsection{Hoisting}

Del inglés "`levantamiento"', el término de hoisting es muy acuñado y asociado a JavaScript. Consiste en mover hacia el comienzo del scope las declaraciones. En términos de compiladores, se puede pensar como una primera pasada del compilador para guardar los identificadores utilizados en el scope. De hecho, lo que sucede es que durante la fase de compilación se reservan en memoria espacio para los nombres declarados.

Gracias a ésta característica, se puede escribir invocar a una función cuyo código está más adelante.

\begin{lstlisting}
foo()
function foo() {
  console.log("bar");
}
\end{lstlisting}

En realidad lo que sucede es que el motor de JavaScript "`mueve"' las declaraciones al principio del scope, por lo que se puede pensar que el código del ejemplo es equivalente a éste:

\begin{lstlisting}
function foo() {
  console.log("bar");
}
foo()
\end{lstlisting}

Para las variables sucede algo similar, aunque solamente en su declaración (no en su asignación), por lo que se puede pensar que el siguiente código:

\begin{lstlisting}
console.log(a); // undefined
var a = 2;
\end{lstlisting}

Es equivalente a esto:

\begin{lstlisting}
var a;
console.log(a);	// undefined
a = 2;
\end{lstlisting}

La precaución hay que tenerla a la hora de escribir funciones como expresión, ya que el hoisting existe en la declaración del nombre pero no en la asignación (tal como pasa con las variables). Por ejemplo, el siguiente código:

\begin{lstlisting}
foo();

var foo = function () { 
  console.log("bar");
}
\end{lstlisting}

Nos lanzará en ejecución un \code{TypeError: foo is not a function}. Tiene sentido pensar en esto, ya que al igual que nos pasó con la variable \code{a}, el código equivalente sería:

\begin{lstlisting}
var foo;

foo();	// en este punto, foo es undefined.

foo = function () { 
  console.log("bar");
}
\end{lstlisting}

\subsection{Closures}

El término de closure, también conocido en español como "`clausura"' o "`cerradura"' es utilizado en otros lenguajes.

\textbf{COMPLETAR}

\subsection{IIFE}

La sigla IIFE representa \textit{Immediately-invoked function expression}, lo que en español sería "`función expresión invocada inmediatamente"'. El término es bastante auto-explicativo: Funciones definidas como expresión (no mediante la declaración normal) que son invocadas en el mismo lugar donde están definidas.

\textbf{COMPLETAR}

?`Qué ventajas nos brindan las IIFEs?

\begin{itemize}
	\item Nos da la posibilidad de simular un scope local.
	\item Proveen un mecanismo de encapsulamiento.
	\item Reducen la polución de nombres en el scope global.
	\item Sirven para crear módulos o namespaces.
\end{itemize}

\subsection{Prototype}
\label{sec:prototype}

Un concepto importante y clave para entender algunos temas a tratar más adelante es el de \code{prototype}. Recordemos que en JavaScript las funciones son objetos, y que los objetos son una colección de propiedades. 

Al momento de declarar una función, se hace una ligadura de un identificador con el valor de un objeto que es instancia de \code{Function}. Dicho objeto tiene una propiedad especial llamada \code{prototype}, la cual es una referencia a otro objeto, inicialmente vacío. Análogamente, dicho objeto tiene una propiedad llamada \code{constructor} que hace referencia al objeto función que creó la instancia.

\begin{lstlisting}[title={Analizando el \code{prototype} de una función}]
function Foo() {}

console.log(Foo.prototype); // {}

// agregamos propiedades al prototipo
Foo.prototype.valor = 42;
Foo.prototype.bar = function() {
  console.log('bar');
};

console.log(Foo.prototype); // { valor: 42, bar: [Function] }

console.log(Foo.prototype.constructor); // [Function: Foo]

\end{lstlisting}

Podemos hacernos una imagen visual sobre las vinculaciones que hay en memoria al momento de la ejecución mediante el siguiente diagrama:

\begin{figure}[th]
\centering
\includegraphics{Figures/Prototype}
\decoRule
\caption[\code{Foo}]{Diagrama del código y los objetos creados.}
\label{fig:prototype}
\end{figure}

Ahora que se mencionó este concepto, tiene sentido revelar que el constructor de clase \code{Object} no es otra cosa más que una función, y sus métodos \code{toString}, \code{valueOf}, ó \code{hasOwnProperty} forman parte de su "`prototipo"'. Ahora supongamos el siguiente código:

\begin{lstlisting}
var a = new Object();

console.log(a.toString());
\end{lstlisting}

La instancia \code{a} también tiene una propiedad del prototipo. Pero en este caso, en vez de ser \code{prototype}, la misma se llama \code{\_\_proto\_\_}. Una definición vaga sería que las funciones están vinculadas a un prototipo mediante su propiedad \code{prototype} mientras que las instancias se vinculan a su prototipo mediante la propiedad \code{\_\_proto\_\_}. La forma "`genérica"' definida en el estandar de ECMAScript cuando se habla del prototipo, es mediante el término \code{[[Prototype]]}.

Ahora, ?`qué sucede exactamente al momento de hacer \code{a.toString()}? En realidad lo que sucede es que se busca dentro del objeto de la instancia de \code{a} por una propiedad \code{toString}, pero al no encontrarse, se seguirá buscando en su \code{[[Prototype]]} (y en caso de no encontrarse, seguiría recursivamente hasta llegar a \code{null}). Ésto es lo que se denomina la cadena del prototipo ("`prototype chain"').

\begin{figure}[th]
\centering
\includegraphics{Figures/Prototype2}
\decoRule
\caption[\code{Object}]{Diagrama del código y la instancia de \code{a}.}
\label{fig:prototype}
\end{figure}

Sobre el uso del \code{prototype} se hablará con más detalle de esto en las secciones \ref{clases} y \ref{herencia}, donde en ésta última se hará mención a su rol en la herencia prototipada.