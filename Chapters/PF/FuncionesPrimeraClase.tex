\section{Funciones de primera clase y orden superior}

Una de las características más destacables del lenguaje es que las funciones son objetos. Gracias a esto, resulta extremadamente simple el pasaje de funciones como argumentos, así como también devolver funciones como un valor de retorno.

\subsection{Funciones de primera clase}

En JavaScript las funciones son objetos de primera clase, dado que las funciones son tratadas como cualquier otro valor. Al momento de crear una función, en realidad lo que se crea es un objeto de clase \code{Function}.

Para el caso de una función mediante declaración, su valor quedará ligado al nombre de la variable dada (siempre que no sea anónima). Para el caso de la función por expresión, dependerá si la misma se realiza en una asignación.

\begin{lstlisting}[title={Analizando el valor de una función}]
function saludar() { console.log('hola'); }
var despedirse = () => console.log('chau');

console.log(saludar);     // [Function: saludar]
console.log(despedirse);  // [Function: despedirse]

console.log(saludar.toString());  
// function saludar() { console.log('hola'); }
console.log(despedirse.toString()); 
// () => console.log('chau')
\end{lstlisting}

El hecho de que las funciones sean tratadas como valores, además, hace que se puedan crear objetos que dentro de sus pares clave-valor tengan propiedades que sean funciones. Es decir, métodos del objeto.

\begin{lstlisting}[title={Asignando una función como valor de una propiedad a un objeto}]
var gato = {
  nombre: 'Mishi',
  maullar: function() {
    console.log('miau');
  }
};

gato.maullar();   
// miau
console.log(gato);  
// { nombre: 'Mishi', maullar: [Function: maullar] }
\end{lstlisting}

\subsection{Funciones de orden superior}

El lenguaje posee la característica de que una función pueda ser pasada como argumento, o que sea el valor de retorno de otra función. Esto conlleva a alcanzar otros mecanismos, como es el \textit{currying}, o como la aplicación parcial.

Comencemos con algunos ejemplos:

\begin{lstlisting}[title={Pasando una función como argumento}]
var saludar = () => console.log('hola mundo!');

function ejecutar(fn) {
  fn();
}

function ejecutarSeguro(fn) {
  if (typeof fn === 'function') {
    fn();
  }
}

ejecutar(saludar);
ejecutarSeguro(saludar);
\end{lstlisting}

En el código mostrado, se poseen dos funciones, \code{ejecutar} y \code{ejecutarSeguro}. La única diferencia es que en la implementación de éste último hay chequeo del tipo del argumento brindado para asegurarse de que es una función y puede invocarla. Para el primer caso, si no le dieramos una función como parámetro, la ejecución de dicha llamada resultaría en un error.

Este tipo de estrategia de pasar funciones como parámetros es de gran utilidad en los \textit{callbacks}, un patrón utilizado para poder manejar la asincronía en el lenguaje. 

La otra cualidad importante para las funciones de alto orden, es la de retornar funciones. Observemos el siguiente ejemplo:

\begin{lstlisting}[title={Retornando funciones}]
function generador(prefijo) {
  return texto => console.log(prefijo + ' ' + texto);
}

var imprimir = generador('Hola');

// En este momento, imprimir es una función!
console.log(typeof imprimir); // function

imprimir('mundo');    // Hola mundo
imprimir('che!');     // Hola che!
imprimir('a todos');  // Hola a todos
\end{lstlisting}

La función \code{generador} tiene un parámetro \code{prefijo} y retorna una función, que tiene un parámetro \code{texto}, y muestra mediante la consola la concatenación del prefijo y del texto. Dado que \code{generador} retorna una función, el valor de la misma es ligada a \code{imprimir}, por lo que tiene sentido pensar que éste es como un alias de la función y se puede invocar sin ningún inconveniente. En el ejemplo, se puede observar como \code{imprimir} de alguna forma "`\textit{recuerda}"' el prefijo que fue establecido al momento de "`generar la función"'.

Veamos otro ejemplo, haciendo una función suma que esté en una forma \textit{curried}:

\begin{lstlisting}[title={Función suma \textit{curried}}]
var sumar = a => b => a + b;

var sumar2 = sumar(2);
var sumar5 = sumar(5);

console.log(sumar2(10));	// 12
console.log(sumar5(10));	// 15
\end{lstlisting}

Si bien la sintaxis de las \textit{arrow functions} al principio puede resultar ajena, la función sumar es una función con un argumento \code{a} y retorna una función, que tiene un argumento \code{b}, la cual retorna la suma de \code{a + b}. De alguna forma, se puede observar como \code{sumar2} y \code{sumar5} son una aplicación parcial de la función \code{sumar}.

Otra forma de realizar aplicación parcián es mediante el método \code{bind} de la clase \code{Function}, el cual recibe como primer argumento el contexto (por lo general sería \code{this}), y luego una lista de argumentos, para retornar la función aplicada (total o parcialmente). Supongamos el siguiente código:

\begin{lstlisting}[title={Aplicación parcial usando \code{bind}}]
var multiplicar = (a, b) => a * b;

var duplicar = multiplicar.bind(null, 2);

console.log(duplicar(15));	// 30
\end{lstlisting}

En este caso, \code{multiplicar.bind} nos retornará una función que será producto de aplicar parcialmente un \code{2} como primer argumento. 

Las funciones de alto orden en el lenguaje son una de las características más poderosas que éste posee. La facilidad con la que se puede pasar o retornar una función brindan un mecanismo que otros lenguajes de programación no pueden alcanzar, y éste es uno de los puntos más fuertes de JavaScript.

