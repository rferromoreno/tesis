\section{Funciones puras}

Las funciones puras son otra de las claves del paradigma funcional. Esto es, funciones que bajo la misma entrada, siempre devuelven el mismo resultado. Esta cualidad brinda la propiedad de transparencia referencial entre los rasgos de un lenguaje perteneciente al paradigma funcional. Los beneficios que trae el uso de las funciones puras, son la testeabilidad, predictibilidad y la falta de efectos colaterales.

Por suerte, en el lenguaje se pueden escribir fácilmente funciones puras. Lamentablemente el lenguaje no posee ninguna directiva, y tampoco existe una herramienta concreta para determinar la pureza (o impureza) de una función, más que el conocimiento del programador.

Algunos ejemplos de funciones puras se pueden ver a continuación:

\begin{lstlisting}[title={Funciones puras}]
function sumar(a, b) {
  return a + b;
}

function esMayor(edad) {
  return edad >= 18;
}

function calcularPrecio(cantidad, costo) {
	return cantidad * costo;
}
\end{lstlisting}

?`Por qué son funciones puras las presentadas previamente? Porque no causan efectos colaterales, y dependen únicamente de sus argumentos para generar un resultado. Ante los mismos argumentos, dichas funciones retornarán los mismos valores. Sin embargo, tal como mencionamos, es muy fácil caer en el uso de funciones impuras:

\begin{lstlisting}[title={Funciones impuras}]
function obtenerDiaActual() {
  return new Date().getDate();
}

function obtenerTextoPorId(id) {
  return document.getElementById(id).textContent;
}

const PI = Math.PI;

function calcularArea(radio) {
  return PI * radio * radio;
}
\end{lstlisting}

La función \code{obtenerDiaActual} retorna un valor "`azaroso"', y dos llamadas a la misma función puede retornar dos valores diferentes (dependiendo de la hora de la computadora). Para el segundo caso, \code{obtenerTextoPorId} depende necesariamente del estado de \code{document} que representa el DOM del navegador. Algo similar sucede con \code{calcularArea}, incluso habiendo declarado a \code{PI} como una "`constante"', la función (de manera aislada) depende de un valor que está por fuera de su scope local, y no nos podemos asegurar de la ausencia de un efecto colateral.

Si bien el lenguaje no provee ningun mecanismo para identificar o limitar únicamente las funciones puras, a continuación se mencionan algunas prácticas para evitar las funciones impuras:

\begin{itemize}
  \item Evitar el uso de variables que estén fuera del ámbito (scope) de la función. Esto incluye también a las variables globales del navegador.
  \item Evitar el uso del DOM o de variables del browser como \code{document} o \code{window}.
	\item Evitar el uso de \code{Math.random}, valores azarosos o cambiantes como el día y la hora actual.
	\item Evitar peticiones bajo el protocolo HTTP u otras que dependan del estado de la red.
	\item Evitar imprimir por pantalla o por consola, o cualquier mecanismo de I/O.
	\item Evitar la mutabilidad de datos. Recordar que los objetos en JS se manejan por referencia. Para éste ítem, se recomienda aplicar prácticas de inmutabilidad, ya sea mediante \code{Object.freeze} o el uso de alguna librería externa.
\end{itemize}
