\chapter{Paradigma orientado a objetos}

\label{Chapter4}

% -----

Uno de los debates principales sobre JavaScript es su soporte hacia el paradigma orientado a objetos. Existe una amplia gama de opiniones y posturas con respecto a JavaScript y su uso dentro de dicho paradigma. Las opiniones pueden ir desde la negativa, es decir, que no lo soporta, hasta la positiva, pasando por un intermedio de que tiene cierto soporte, pero no naturalmente.

En éste capítulo se buscará realizar un análisis sobre características típicas del paradigma orientado a objetos, tratándo de ver de qué manera llega JavaScript a éstas características.

% -----

\section{Clases}

Previo a la salida de ES6 (es decir, en la version 5 de JavaScript) la creación de clases en JavaScript se realiza mediante el uso de patrones para la creación de objetos. La realidad es que en JavaScript no existe un soporte formal o natural para las clases, sino que hay que recurrir a estos patrones para simularlo. Los más populares, a mi entender, son:

\begin{itemize}
	\item Factory class pattern
	\item Functional class pattern
	\item Prototype class pattern
\end{itemize}

\subsection{Factory class pattern}

Se trata de una función de tipo \textit{factory} (fábrica) utilizada para crear elementos u objetos, con ciertas propiedades y bajo cierto comportamiento. En nuestro caso, dicha función será quien cree nuestras nuevas instancias de lo que queremos moldear como clase.

\begin{lstlisting}[title={Factory class pattern}]
function animalFactory(nombre) {
  var temporal = {};
  temporal.nombre = nombre;
  temporal.saludar = function() {
    console.log("Hola, soy "+this.nombre)
  };

  return temporal;
}

var gato = animalFactory("Garfield");
var perro = animalFactory("Oddie");

gato.saludar();		// Hola, soy Garfield
perro.saludar();	// Hola, soy Oddie
\end{lstlisting}

Si bien puede resultar un poco confuso al principio, para quienes estén acostumbrados al patrón Factory, este ejemplo quizás resulte más trivial. A simple vista, la única \textit{ventaja} es que no se necesita usar \code{new} a la hora de realizar la instanciación de nuevos objetos. 

Para el objetivo que buscamos, que es simular el soporte de clases, este patrón es útil.

\subsection{Functional class pattern}

Este patrón también es conocido como Constructor pattern. Aprovechando el uso de la palabra \code{new}, podemos omitir la creación de un objeto temporal dentro de nuestra función. De hecho, la palabra \code{new} no solamente crea un nuevo objeto (instancia), sino que además establece quién fue la función de construcción (se puede pensar como "`de quién hereda el objeto"').

\begin{lstlisting}[title={Functional class pattern}]
function Animal(nombre) {
  this.nombre = nombre;
  this.saludar = function() {
    console.log('Hola, soy ' + this.nombre);
  };
};

var gato = new Animal('Garfield');
var perro = new Animal('Oddie');

gato.saludar();		// Hola, soy Garfield
perro.saludar();	// Hola, soy Oddie
\end{lstlisting}

Notar las diferencias con el ejemplo del Factory Pattern. Por un lado, el uso del \code{this} dentro de la función y la falta de necesidad de retornar el objeto (esto sucede implícitamente gracias al \code{new}). Por otro lado, a la hora de crear instancias es importante utilizar la palabra \code{new}.

Un detalle muy importante a tener en cuenta tanto en éste patrón como en el Factory pattern: Para cada instancia creada, la misma poseerá una copia del código de \code{saludar()} en memoria. Parece un detalle menor, pero supongamos que en vez de un solo método, nuestra clase tiene varios, y que ademas precisamos generar una gran cantidad de instancias, significaría estar desperdiciando espacio en memoria.

También para tener en cuenta: No existen reglas ni restricciones sobre los nombres de las funciones constructoras, pero existe una convención entre los programadores de usar la letra capital en los nombres de las funciones constructoras (esto es, que la primera letra sea mayúscula).

\subsection{Prototype class pattern}

Para tratar de resolver el problema recién mencionado, en donde cada instancia tiene una copia del código de la función, es necesario hacer un buen uso del concepto de prototipo en JavaScript.

\begin{lstlisting}[title={Prototype class pattern}]
function Animal(nombre) {
  this.nombre = nombre;
}

Animal.prototype.saludar = function() {
  console.log('Hola, soy ', this.nombre);
};

var gato = new Animal('Garfield');
var perro = new Animal('Oddie');

perro.saludar(); 	// Hola, soy Garfield
gato.saludar(); 	// Hola, soy Oddie
\end{lstlisting}


\subsection{\code{class} en ES6}

A partir de la versión ES6, una de las características más jugosas es la del uso de la palabra reservada \code{class}.

\begin{lstlisting}[title={Ejemplo de \code{class}}]

\end{lstlisting}



\section{Herencia}

Como se ha mencionado anteriormente, JavaScript tiene la particularidad de tener la herencia prototipada en vez de la herencia clásica. 

\subsection{Herencia múltiple}

Dado que los objetos "`heredan"' de un único prototipo, el lenguaje no provee ninguna herramienta natural para el soporte de la herencia múltiple. Otros lenguajes buscan alcanzar la herencia múltiple mediante el uso de interfaces

\section{Encapsulamiento y principio de ocultación}

Dependiendo la perspectiva, se puede decir que el lenguaje tampoco provee un mecanismo natural para el encapsulamiento. Si hablamos de ocultar el estado de un objeto, es decir, de hacer sus datos miembro privados, no existe ninguna palabra reservada para ello. De hecho, todas las propiedades de un objeto son públicas.

Existe una convención extra oficial de que los miembros privados de un objeto comiencen su identificador con un guión bajo. Nuevamente, ésta no es una convención del lenguaje, sino de la comunidad. Más allá de la convención, volvemos a lo mismo: Por fuera se puede analizar cuál es el valor ligado a dicha propiedad.

\begin{lstlisting}[title={Descubriendo variables "`privadas"'}]
class Persona {
  constructor(nombre, saldo) {
    this.nombre = nombre;
    this._saldo = saldo;
  }
}

var pepe = new Persona('Jose', 25);

console.log(pepe.nombre);	// Jose
console.log(pepe._saldo);	// 25
\end{lstlisting}

Como se puede observar en el ejemplo, se busca hacer privada la propiedad \code{\_saldo}, pero sin embargo es visible desde afuera del objeto.

Por suerte mediante el uso de \textit{closures}, se puede lograr el encapsulamiento, pero solo mediante el uso de funciones constructoras. Lamentablemente, para la sintaxis de \code{class} de ES6 no hay soporte nativo aún. Al momento de escribirse este documento, existe una propuesta en borrador para agregar al lenguaje, la cual se encuentra en \textit{Stage 3} (para más información, ver \href{https://github.com/tc39/proposal-class-fields#private-fields}).

\begin{lstlisting}[title={Alcanzando variables privadas mediante closures}]
function Persona(nombre, saldo) {
  var saldoPrivado = saldo;
  this.nombre = nombre;
  this.obtenerSaldo = function() {
    return saldoPrivado;
  }
  this.actualizarSaldo = function(nuevoSaldo) {
    saldoPrivado = nuevoSaldo;
  }
}

var pepe = new Persona('Jose', 25);

console.log(pepe.nombre);					// Jose
console.log(pepe.saldoPrivado);		// undefined
// OK, ya que es una propiedad privada.
console.log(pepe.obtenerSaldo());	// 25
pepe.actualizarSaldo(32);
console.log(pepe.obtenerSaldo());	// 32
\end{lstlisting}

Un detalle menos obvio pero aún así importante, es que necesariamente los \textit{setters} y \textit{getters} de las variables ocultas por el closure deberán formar parte de la función constructora (es decir, no podrán definirse dentro del prototipo), lo que significa nuevamente que cada instancia de \code{Persona} tendrá código repetido, lo que implica gasto en memoria. Bajo esta situación, nos encontramos en un \textit{trade-off} de tener datos miembro privados, pero no poder hacer uso correcto del patrón prototipal.

\section{Polimorfismo}

\section{Abstracción}

\section{Modularidad}

\section{Lo bueno, lo malo, lo feo...}