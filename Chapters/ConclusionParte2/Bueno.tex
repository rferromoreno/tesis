\section{Lo bueno}

\begin{itemize}
\item Lo bueno: 
JavaScript no será un lenguaje de programación funcional pura, pero el hecho de que las funciones sean valores dentro del lenguaje lo hace excesivamente poderoso. Poseer funciones como valores, permitir el paso de las mismas como argumentos o como valores de retorno hace al lenguaje sumamente expresivo.
Para la enseñanza de conceptos básicos de la programación funcional, con una sintaxis similar a la familia de lenguajes de C, es un buen lenguaje, más allá de la falta de todas las propiedades que corresponden a un lenguaje 100\% del paradigma funcional.
\item Lo malo: 
La falta de evaluación perezosa, semántica de valores, transparencia referencial, entre otras cosas, lo alejan del paradigma funcional. Sin embargo, si tuviera éstas características seguramente tendríamos que limitar al lenguaje en otros aspectos, y probablemente quitarle el soporte para otros paradigmas de programación. 
\end{itemize}


\begin{itemize}
\item Lo bueno: 
La herencia prototipal y su poder. El modelo de delegación de comportamiento y la cadena de prototipo, y la falta de necesidad de copiar o guardar lugar en memoria para los miembros de la superclase seguramente lo hacen más liviano. 
La sintaxis de clase de ES6 fue probablemente una de las mejores características lanzadas para el lenguaje. Permite a muchos programadores meterse en el lenguaje sin necesidad de cambiarles la mentalidad de herencia clásica a la prototipal.
Dicho todo esto, JavaScript es un verdadero lenguaje orientado a objetos, mientras que otros lenguajes son orientados a clases.
El polimorfismo (o en realidad la falta de chequeos en "`compilación"') es otro punto a destacar. Le saca rigurosidad (y seguridad) al lenguaje incrementando su flexibilidad. Si quiero invocar a un método de un objeto y éste no existe, se buscará en la cadena de prototipo hasta terminar con la cadena, y en caso de que así sea, habrá un error en ejecución.
Otra característica que también merece una mención es la de los módulos de ES6, ya que de una manera clara y concisa se pueden separar espacios de nombres y manejar las dependencias sin la necesidad de pensar en ellas.
\item Lo malo: 
La falta de soporte natural para las clases es algo que deja que desear del lenguaje. Para ser justos con él, no fue pensado para tener clases (y es por eso que no tiene herencia clásica), y aún así los programadores buscan llegar a las mismas. Sin embargo, el soporte dado a las clases en ES6 es únicamente sintáctico, y el estándar parece estar conforme con dichas bases como para seguir evolucionando en éste punto. 
La asignación "`manual"' del prototipo de una función al querer simular la herencia clásica es un arma de doble filo, ya que si bien nos da libertades, es muy fácil perderse entre las relaciones que hay entre los objetos. Por otro lado, la poca popularidad de la herencia prototipal hace de JavaScript un lenguaje más difícil de comprender.
\item Lo feo: 
No poder poseer miembros privados, ya sean atributos o funciones, y tener que recurrir a aplicar mecanismos como closures e IIFEs para alcanzar esto. Todos los métodos y los atributos cargados en un objeto serán públicos y habrá que pensar en un buen diseño de aplicación para no tener problema con ello. Por suerte, los módulos de ES6 solucionan una parte de esto, ya que de forma implícita, los métodos que no se exporten en un módulo valdrán como métodos privados para ese módulo.
\end{itemize}