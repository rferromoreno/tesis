\section{El operador \code{+}}
\label{sec:operadormas}

Uno de los grandes dilemas a la hora de diseñar un lenguaje es sobre el uso de operadores como el \code{+}. ?`Debería este operador estar sobrecargado?. Es simple pensar en el \code{+} como un operador de suma de dos datos numéricos, pero ?`se podría usar para concatenar dos cadenas de texto? ?`o para unir el contenido de dos listas (arreglos)?.

\subsection{Operador unario}

La existencia del operador unario \code{+} puede resultar en una de las más confusas del lenguaje. La única finalidad del operador unario \code{+} es hacer una conversión numérica en caso de ser posible, y en caso contrario retornar \code{NaN}. No funciona de la misma forma en la que funcionaría el operador unario \code{-} (negación matemática), en donde además de realizar la conversión numérica, intentará cambiar el signo. Por ejemplo:

\begin{lstlisting}[title={Operador unario \code{+}}]
+3				// 3
-3				// -3
+(-3)			// -3
+-3				// -3
-+3				// -3
\end{lstlisting}

Insistimos, este operador funciona únicamente para una conversión a número, pero tiene influencia sobre el signo. Dicho esto, se presentan a continuación algunos ejemplos con sus respectivos resultados.

\begin{lstlisting}[title={Operador unario \code{+} (más casos)}]
+3                                   // 3
+'-3'                                // -3
+'3.14'                              // 3.14
+'3'                                 // 3
+'0xFF'                              // 255
+true                                // 1
+'123e-5'                            // 0.00123
+false                               // 0
+null                                // 0
+'Infinity'                          // Infinity
+'infinity'                          // NaN
+function(val){  return val }        // NaN
\end{lstlisting}

El operador unario \code{+} suele ser el elegido por algunos programadores cuando quieren hacer coerción explícita de un valor a su tipo numérico. Los resultados de utilizar \code{Number()} para ambos casos serían idénticos. El \textit{trade-off} está en la legibilidad de las expresiones cuando éstas se vuelven más complejas. Se gana simplicidad, pero se sacrifica legibilidad.

\subsection{Operador binario}

Para comenzar, iremos con el ejemplo más simple de todos: El operador \code{+} sirve como suma a la hora de trabajar con datos numéricos.

\begin{lstlisting}[title={Operador \code{+} en números}]
1 + 2 			// 3
10 + 50 		// 60
.1 + 0			// 0.1
NaN + NaN		// NaN
-1 + 10			// 9
\end{lstlisting}

Por otro lado, el mismo operador también se puede usar para concatenación de strings.

\begin{lstlisting}[title={Operador \code{+} en strings}]
"hola" + "mundo"	// "holamundo"
"abc" + "def"			// "abcdef"
"123" + "456"			// "123456"
"chau" + ""				// "chau"
\end{lstlisting}

Hasta este punto, todo parece funcionar de acuerdo a lo esperado. JavaScript actúa de forma bastante similar a otros lenguajes que poseen el operador \code{+} sobrecargado. El problema comienza cuando empezamos a "`mezclar"' los tipos. Empecemos analizando los casos de \code{number} y \code{string}:

\begin{lstlisting}[title={Operador \code{+} mezclando strings con números}]
1 + "1"				// "11"
"1" + 1				// "11"
2 + ""				// "2"
"hola" + 0		// "hola0"
\end{lstlisting}

Si bien puede parecer un poco raro, la regla aquí es que si uno de los operandos es \code{string}, entonces el resultado será la concatenación de los \code{string}. Ahora sigamos evaluando, qué pasa con los \code{boolean}:

\begin{lstlisting}[title={Operador \code{+} en booleanos}]
true + true		// 2
true + false	// 1
false + false	// 0
\end{lstlisting}

Tal como se mencionó en la sección \ref{sec:conversionexplicita}, el valor numérico de \code{true} es \code{1} mientras que el de \code{false} es \code{0}. Entonces para este caso, ocurre una coerción hacia tipo numérico en los operandos, y el operador \code{+} funciona como una suma numérica normal.

Para entender mejor lo que está sucediendo, es preferible tener a mano un pseudo algoritmo de cómo trabaja el operador binario \code{+}:

\begin{enumerate}
\item Convertir ambos operandos a sus valores primitivos haciendo uso del \code{ToPrimitive} mencionado anteriormente.
\item Si alguno de los dos operandos es \code{string}, convertir ambos operandos a \code{string} y retornar la concatenación de los resultados.
\item Sino, convertir ambos operandos a su valor numérico y retornar la suma de los resultados.
\end{enumerate}

Considerando esto, evaluemos algunos casos más:

\begin{lstlisting}[title={Operador \code{+} con arreglos y objetos}]
[] + []			// ''
[] + {}			// '[object Object]'
{} + {}			// '[object Object][object Object]'
{} + []			// 0
\end{lstlisting}

Para el primer caso, la conversión a primitivo del arreglo vacío \code{[]} primero hace un \code{valueOf()}, el cual retorna el arreglo mismo (\code{this}). Luego, como el resultado no es un valor primitivo, se hace \code{toString()} el cual retorna el string vacío \code{''}. Finalmente, el resultado de sumar \code{[] + []} es el string vacío.

Para el segundo caso, sucede algo similar. Dado que el primer operando es el string vacío, entonces el \code{+} corresponde a una concatenación de strings. Y el método \code{toString()} sobre un objeto (instancia directa de Object) se traduce a string de la forma \code{``[object Object]''}.

Luego de haber visto los dos primeros casos, el tercer caso se explica solo. Se hace la conversión del primero y el \code{+} representa la concatenación de strings. Sucede exactamente lo mismo que en el primer caso, el \code{valueOf()} del primer operando retorna \code{this} entonces se termina haciendo un \code{toString()}.

El que es bastante inusual es el cuarto caso. Luego de haber visto el segundo, uno tiende a esperar que el cuarto de el mismo resultado, pero esto no es así. ?`Qué pasó? El intérprete consideró a la primera parte de la expresión como un bloque de código vacío y la ignoró. Luego, la expresión quedó como \code{+[]}, donde el \code{+} representa el operador unario, no el binario. Lo que significa que resultó en una coerción hacia \code{number} del string vacío \code{''}, resultando en un \code{0}. Podemos "`corregir"' este comportamiento haciendo uso de los paréntesis, entonces el intérprete lo leerá como una expresión y \code{\{\}} representará un objeto en vez de un bloque.

\begin{lstlisting}[title={Caso especial}]
({} + [])			// '[object Object]'
\end{lstlisting}

El hecho de que los arreglos estén vacíos o sean mezclados con objetos no cambia el resultado. Si tenemos dos arreglos con contenido, el resultado será de todas formas convertido a \code{string}. Ejemplificando:

\begin{lstlisting}[title={Operador \code{+} entre arreglos}]
var a = [1, 2, 3];
var b = [4, 5, 6];

var resultado = a + b;

console.log(typeof resultado);	// string​​​​​
console.log(resultado)					// '1,2,34,5,6'​​​​​
\end{lstlisting}

Con todo esto visto, ahora se tiene un mejor panorama de cómo funciona el operador \code{+} en JavaScript. Se utiliza principalmente en valores de tipos numéricos o strings. 

Para el caso de los objetos, si alguno de los operandos es string, el mismo se convierte a string, en caso contrario, se convierte a número. 

Para el caso de los arreglos, el operador \code{+} no funciona como en otros lenguajes. Para concatenar arreglos es necesario utilizar el método \code{concat} o hacer uso de alguna librería externa. 